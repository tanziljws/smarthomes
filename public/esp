#include <WiFiManager.h>
#include <ArduinoJson.h>
#include <PubSubClient.h>
#include <ESP8266WebServer.h>
#include <EEPROM.h> // Untuk menyimpan pengaturan di memori non-volatile
#include <DHTesp.h> // Library untuk sensor DHT

const char* mqttServer = "192.168.2.84"; // IP of your MQTT broker
const int mqttPort = 1883;
const char* mqttUser = "root";
const char* mqttPassword = "adminse10";
const char* publishStatusTopic = "smarthome/status";
const char* subscribeControlTopic = "smarthome/control";
const char* publishDhtTopic = "smarthome/dht";  // Topic untuk data DHT
const char* publishAirQualityTopic = "smarthome/air_quality"; // Topic untuk kualitas udara
const char* subscribeClapSettingTopic = "smarthome/clap_setting"; // Topic untuk pengaturan tepukan
const char* subscribeThresholdTopic = "smarthome/sound_threshold";

// Relay pins
const int relayPins[] = {D0, D1, D2, D3};
int relayState[4] = {LOW, LOW, LOW, LOW}; // Store relay states
int clapRelay = 0; // Relay yang dikontrol oleh tepukan (default relay 1)

// DHT Sensor
const int dhtPin = D5;  // Pin data untuk DHT
DHTesp dht;

// ZPH-300F Sensor
const int airQualityPin = A0; // Pin ADC untuk ZPH-300F

// MAX9814 Sound Sensor
const int soundSensorPin = D7; // Pin analog untuk MAX9814
int soundThreshold = 600; // Default threshold
const int clapDebounceTime = 200; // Waktu debounce untuk tepukan (ms)
bool allRelaysOn = false; // Status semua relay

WiFiClient espClient;
PubSubClient client(espClient);

// Tambah variable global
bool clapFeatureEnabled = false;

void setup() {
  Serial.begin(115200);
  Serial.println("\n=== Smart Home System Starting ===");

  EEPROM.begin(512);
  
  // Baca nilai awal
  clapRelay = EEPROM.read(0);
  Serial.println("Initial EEPROM value: " + String(clapRelay));
  
  // Validasi nilai
  if (clapRelay < 0 || clapRelay > 3) {
    Serial.println("Invalid value in EEPROM, resetting to 0");
    clapRelay = 0;
    EEPROM.write(0, clapRelay);
    EEPROM.commit();
  }
  
  Serial.println("Using clap relay: " + String(clapRelay));
  
  // Initialize relay pins
  for (int i = 0; i < 4; i++) {
    pinMode(relayPins[i], OUTPUT);
    digitalWrite(relayPins[i], LOW);
  }

  // Read and print initial settings
  clapRelay = EEPROM.read(0);
  Serial.println("Initial clap relay from EEPROM: " + String(clapRelay));
  
  // Baca threshold dari EEPROM
  int lowByte = EEPROM.read(1);
  int highByte = EEPROM.read(2);
  int savedThreshold = (highByte << 8) | lowByte;
  if (savedThreshold > 0 && savedThreshold <= 1024) {
    soundThreshold = savedThreshold;
  }

  Serial.println("Loaded settings from EEPROM:");
  Serial.println("Clap Relay: " + String(clapRelay));
  Serial.println("Sound Threshold: " + String(soundThreshold));

  // Initialize DHT sensor
  dht.setup(dhtPin, DHTesp::DHT11);  // Gunakan DHT11, ubah ke DHT22 jika pakai DHT22

  // Initialize WiFi and MQTT
  setupWiFi();
  setupMQTT();
}

void loop() {
  if (!client.connected()) {
    reconnectMQTT();
  }
  client.loop();

  static unsigned long lastDhtUpdate = 0;
  if (millis() - lastDhtUpdate >= 2000) {  // Update DHT data setiap 2 detik
    sendDhtData();
    lastDhtUpdate = millis();
  }

  static unsigned long lastAirQualityUpdate = 0;
  if (millis() - lastAirQualityUpdate >= 5000) {  // Update kualitas udara setiap 5 detik
    sendAirQualityData();
    lastAirQualityUpdate = millis();
  }

  // Check for clapping
  detectClapping();
}

void setupWiFi() {
  WiFiManager wifiManager;
  if (!wifiManager.autoConnect("SmartHome_Config")) {
    Serial.println("Failed to connect to WiFi. Restarting...");
    delay(3000);
    ESP.restart();
  }
  Serial.println("Connected to WiFi");
}

void setupMQTT() {
  client.setServer(mqttServer, mqttPort);
  client.setCallback(mqttCallback);
  reconnectMQTT();
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  // Convert payload to string for easier handling
  String message = "";
  for (unsigned int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  
  Serial.println("\n=== MQTT Message Received ===");
  Serial.println("Topic: " + String(topic));
  Serial.println("Payload length: " + String(length));
  Serial.println("Raw payload: " + message);

  if (String(topic) == subscribeClapSettingTopic) {
    Serial.println("Processing clap settings...");
    
    StaticJsonDocument<200> doc;
    DeserializationError error = deserializeJson(doc, payload, length);

    if (!error) {
      // Update enabled status
      if (doc.containsKey("enabled")) {
        clapFeatureEnabled = doc["enabled"];
        Serial.println("Clap feature " + String(clapFeatureEnabled ? "enabled" : "disabled"));
      }

      // Update relay if provided
      if (doc.containsKey("deviceId")) {
        int deviceId = doc["deviceId"];
        if (deviceId >= 0 && deviceId <= 3) {
          clapRelay = deviceId;
          EEPROM.write(0, clapRelay);
          EEPROM.commit();
          Serial.println("Clap relay updated to: " + String(clapRelay));
        }
      }
    }
  } else if (String(topic) == subscribeControlTopic) {
    for (int i = 0; i < 4; i++) {
      String relayOnCommand = "RELAY" + String(i + 1) + "_ON";
      String relayOffCommand = "RELAY" + String(i + 1) + "_OFF";
      
      if (message == relayOnCommand) {
        controlRelay(i, LOW, relayOnCommand);
      } else if (message == relayOffCommand) {
        controlRelay(i, HIGH, relayOffCommand);
      }
    }
  } else if (String(topic) == subscribeThresholdTopic) {
    StaticJsonDocument<200> doc;
    DeserializationError error = deserializeJson(doc, payload, length);

    if (!error) {
      int newThreshold = doc["threshold"];
      if (newThreshold > 0 && newThreshold <= 1024) {
        soundThreshold = newThreshold;
        EEPROM.write(1, newThreshold & 0xFF);
        EEPROM.write(2, (newThreshold >> 8) & 0xFF);
        EEPROM.commit();
        Serial.println("Sound threshold updated: " + String(soundThreshold));
      }
    }
  }
}



void controlRelay(int relayIndex, int state, String command) {
  if (relayIndex >= 0 && relayIndex < 4) {
    digitalWrite(relayPins[relayIndex], state);
    relayState[relayIndex] = state;
    client.publish(publishStatusTopic, command.c_str());
    Serial.println("Published: " + command);
  }
}

void reconnectMQTT() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    
    if (client.connect("SmartHomeClient", mqttUser, mqttPassword)) {
      Serial.println("connected!");
      
      // Subscribe to topics
      bool controlSub = client.subscribe(subscribeControlTopic);
      bool clapSub = client.subscribe(subscribeClapSettingTopic);
      bool thresholdSub = client.subscribe(subscribeThresholdTopic);
      
      Serial.println("\nSubscription Results:");
      Serial.println("- Control topic: " + String(controlSub ? "SUCCESS" : "FAILED"));
      Serial.println("- Clap settings: " + String(clapSub ? "SUCCESS" : "FAILED"));
      Serial.println("- Threshold: " + String(thresholdSub ? "SUCCESS" : "FAILED"));
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" retrying in 5 seconds");
      delay(5000);
    }
  }
}

void sendDhtData() {
  TempAndHumidity data = dht.getTempAndHumidity();

  if (dht.getStatus() == DHTesp::ERROR_NONE) {
    String payload = "{";
    payload += "\"temperature\": " + String(data.temperature, 1) + ", ";
    payload += "\"humidity\": " + String(data.humidity, 1);
    payload += "}";

    client.publish(publishDhtTopic, payload.c_str());
    Serial.println("DHT data sent: " + payload);
  } else {
    Serial.println("Failed to read from DHT sensor");
  }
}

void sendAirQualityData() {
  int airQualityValue = analogRead(airQualityPin); 
  String airQualityStatus = airQualityValue < 300 ? "Good" : airQualityValue < 600 ? "Moderate" : "Poor";

  String payload = "{";
  payload += "\"air_quality\": " + String(airQualityValue) + ", ";
  payload += "\"status\": \"" + airQualityStatus + "\"";
  payload += "}";

  client.publish(publishAirQualityTopic, payload.c_str());
  Serial.println("Air quality data sent: " + payload);
}

void detectClapping() {
  // Return early if feature is disabled
  if (!clapFeatureEnabled) return;
  
  static unsigned long lastClapTime = 0;
  static unsigned long doubleClapTimer = 0;
  static int clapCount = 0;

  int soundValue = analogRead(soundSensorPin);
  static int smoothedSoundValue = 0;
  smoothedSoundValue = (smoothedSoundValue * 3 + soundValue) / 4;

  if (smoothedSoundValue > soundThreshold && (millis() - lastClapTime > clapDebounceTime)) {
    lastClapTime = millis();
    clapCount++;
    Serial.println("Clap detected! Current relay setting: " + String(clapRelay));

    if (clapCount == 1) {
      doubleClapTimer = millis();
    }

    if (clapCount == 2 && millis() - doubleClapTimer <= 1000) {
      Serial.println("\n=== Double Clap Detected ===");
      
      // Validasi clapRelay sebelum menggunakannya
      if (clapRelay < 0 || clapRelay > 3) {
        Serial.println("Invalid relay value, resetting to 0");
        clapRelay = 0;
        EEPROM.write(0, clapRelay);
        EEPROM.commit();
      }
      
      Serial.println("Active relay: " + String(clapRelay));
      Serial.println("Current relay state: " + String(relayState[clapRelay]));

      // Toggle relay
      relayState[clapRelay] = !relayState[clapRelay];
      digitalWrite(relayPins[clapRelay], relayState[clapRelay]);

      String command = "RELAY" + String(clapRelay + 1) + (relayState[clapRelay] == LOW ? "_ON" : "_OFF");
      Serial.println("Publishing command: " + command);
      client.publish(publishStatusTopic, command.c_str());
    }
  }

  if (clapCount > 0 && millis() - doubleClapTimer > 1000) {
    clapCount = 0;
  }
}